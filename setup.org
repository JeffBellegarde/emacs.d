#+TITLE: Jeff Bellegarde's Emacs configuration
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args    :results silent

* To be done

* Emacs Basics
** Install emacs
Emacs needs to be installed before this can even run. Still provides a nice place to track the command line args.



#+begin_src sh
brew install emacs --with-cocoa --with-imagemagick --with-gnutls
#+end_src

** Personal information

Who I am.
#+BEGIN_SRC emacs-lisp results:silent
  (setq user-full-name "Jeff Bellegarde"
        user-mail-address "bellegar@gmail.com")
#+END_SRC

** Basic config
#+begin_src emacs-lisp
  (require 'use-package)
  (column-number-mode)
  (tool-bar-mode -1)
  (line-number-mode 1)
  (add-hook 'after-init-hook 'server-start)
  (add-hook 'edit-server-start-hook 'ns-raise-emacs-with-frame)

  ;;mode-compile
  (autoload 'mode-compile "mode-compile"
    "Command to compile current buffer file based on the major mode" t)
  (global-set-key "\C-cc" 'mode-compile)
  (autoload 'mode-compile-kill "mode-compile"
    "Command to kill a compilation launched by `mode-compile'" t)
  (global-set-key "\C-ck" 'mode-compile-kill)
  (global-set-key "\C-z" 'undo)
  (autoload 'git-mergetool-emacsclient-ediff "git-ediff" "Run Ediff for git" t)
  (auto-compression-mode 1)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq use-dialog-box nil)

  (setq ring-bell-function (lambda () (message "*beep*")))
  (transient-mark-mode 1)

#+end_src
** Customization
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "emacs-customizations.el" jmb-emacs-config-dir))
(load custom-file)
#+end_src
** Startup test
This will verify that emacs startup is working correctly.
From http://oremacs.com/2015/03/05/testing-init-sanity/

#+begin_src emacs-lisp
(defun ora-test-emacs ()
  (interactive)
  (require 'async)
  (async-start
   (lambda () (shell-command-to-string
          "emacs --batch --eval \"
(condition-case e
    (progn
      (load \\\"~/.emacs.d/init.el\\\")
      (message \\\"-OK-\\\"))
  (error
   (message \\\"ERROR!\\\")
   (signal (car e) (cdr e))))\""))
   `(lambda (output)
      (if (string-match "-OK-" output)
          (when ,(called-interactively-p 'any)
            (message "All is well"))
        (switch-to-buffer-other-window "*startup error*")
        (delete-region (point-min) (point-max))
        (insert output)
        (search-backward "ERROR!")))))
#+end_src

** Personal key bindings
#+begin_src emacs-lisp
(bind-key "C-h K" 'describe-personal-keybindings)
#+end_src

* Launcher

The launcher map is defined at the top so other things can add to it.

#+begin_src emacs-lisp
(define-prefix-command 'launcher-map)
(define-key ctl-x-map "l" 'launcher-map)
(global-set-key (kbd "s-l") 'launcher-map)
(define-key launcher-map "c" #'calc)
(define-key launcher-map "d" #'ediff-buffers)
;;(define-key launcher-map "f" #'find-dired)
(define-key launcher-map "a" #'ack)
(define-key launcher-map "e" #'elfeed)
(define-key launcher-map "h" #'man) ; Help
(define-key launcher-map "i" #'package-install-from-buffer)
(define-key launcher-map "g" #'gnus)
;;(define-key launcher-map "n" #'nethack)
(define-key launcher-map "l" #'count-lines-page)
(define-key launcher-map "p" #'paradox-list-packages)
(define-key launcher-map "s" #'shell)
(define-key launcher-map "t" #'proced) ; top
#+end_src
* Global Minor Modes
** Winner (window layouts)
Binds C-c <left> and C-c <right>
#+begin_src emacs-lisp
(when (fboundp 'winner-mode)
      (winner-mode 1))
#+end_src

** Helm

*** Basic


Use ack and use resursive by default. C-u to be non-recursive.

#+BEGIN_SRC emacs-lisp  :results silent
  (use-package helm
    :ensure t
    :bind (
           ("C-c h" . helm-command-prefix)
           ("M-x" . helm-M-x)
           ("C-x b" . helm-mini)
           ("C-h SPC" . helm-all-mark-rings)
           ("C-x C-f" . helm-find-files)
           ("M-y" . helm-show-kill-ring))
    :config (progn
              (require 'helm-config)
              (helm-mode 1)
              (global-unset-key (kbd "C-x c"))
              ;;rebind the keys
              (bind-key "C-c h g" 'helm-google-suggest)
              (bind-key "C-c h o" 'helm-occur)
              (bind-key "C-c h x" 'helm-register)
              (bind-key "C-c h M-:" 'helm-eval-expression-with-eldoc)
              (setq helm-M-x-fuzzy-match t)
              (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
              (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
              (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
              (define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)
              (when (executable-find "ack")
                (setq helm-grep-default-command "ack -H --no-group --no-color %p %f"
                      helm-grep-default-recurse-command "ack -Hn --no-group --no-color %p %f"))))
#+END_SRC

*** Descbinds
#+begin_src emacs-lisp
  (use-package helm-descbinds
    :ensure t
    :defer t
    :bind ("C-h b" . helm-descbinds)
    :config
    (progn
      (helm-descbinds-mode)))
#+end_src

*** swoop

#+begin_src emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind
    (("M-i" . helm-swoop)
     ("M-I" . helm-swoop-back-to-last-point)
     ("C-c M-i" . helm-multi-swoop)
     ("C-x M-i" . helm-multi-swoop-all)))
#+end_src


*** ag

Funcationality enabled but not bound to anything yet.

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
    :ensure t
    :commands (helm-ag helm-do-agg))

#+END_SRC

** Hydra
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t
    :bind ( ("C-M-o" . hydra-window/body)
            ("<f2>" . hydra-zoom/body)
            ("C-x SPC" . hydra-rectangle/body))
    :chords (("jk" . hydra-window/body)
             ("jl" . hydra-navigate/body))
    :commands (defhydra)
    :config
    (hydra-add-font-lock)
    (defhydra hydra-zoom (global-map "<f2>")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out")
      ("0" (text-scale-set 0) "reset"))

    (defun hydra-move-splitter-left (arg)
      "Move window splitter left."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (shrink-window-horizontally arg)
        (enlarge-window-horizontally arg)))

    (defun hydra-move-splitter-right (arg)
      "Move window splitter right."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'right))
          (enlarge-window-horizontally arg)
        (shrink-window-horizontally arg)))

    (defun hydra-move-splitter-up (arg)
      "Move window splitter up."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (enlarge-window arg)
        (shrink-window arg)))

    (defun hydra-move-splitter-down (arg)
      "Move window splitter down."
      (interactive "p")
      (if (let ((windmove-wrap-around))
            (windmove-find-other-window 'up))
          (shrink-window arg)
        (enlarge-window arg)))

    (defhydra hydra-window (:color amaranth)
      "window"
      ("h" windmove-left)
      ("j" windmove-down)
      ("k" windmove-up)
      ("l" windmove-right)
      ("H" hydra-move-splitter-left)
      ("J" hydra-move-splitter-down)
      ("K" hydra-move-splitter-up)
      ("L" hydra-move-splitter-right)

      ("3" (lambda ()
             (interactive)
             (split-window-right)
             (windmove-right))
       "vert")
      ("2" (lambda ()
             (interactive)
             (split-window-below)
             (windmove-down))
       "horz")
      ("t" transpose-frame "'")
      ("1" delete-other-windows "one" :color blue)
      ("a" ace-window "ace")
      ("s" ace-swap-window "swap")
      ("d" ace-delete-window "del")
      ("i" ace-maximize-window "ace-one" :color blue)
      ("b" helm-mini "buf")
      ;;("m" headlong-bookmark-jump "bmk")
      ("q" nil "cancel"))
    (global-set-key (kbd "C-M-o") 'hydra-window/body)
    (key-chord-define-global "jk" 'hydra-window/body)

    (defhydra hydra-navigate (:color amaranth)
      "navigate"
      ("k" beginning-of-defun "beginning-of-defun")
      ("j" end-of-defun "end-of-defun")
      ("h" er/expand-region "expand-region")
      ("l" er/contract-region "contract-region")
      ("a" move-beginning-of-line "line start")
      ("e" move-end-of-line "line end")
      ("SPC" set-mark-command :color red)
      ("n" narrow-to-region "narrow")
      ("q" nil "cancel"))
  ;;  (key-chord-define-global "jl" 'hydra-navigate/body)

    (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                         :color pink
                                         :post (deactivate-mark))
      "
      _k_   ^^_d_elete    _s_tring
    _h_ _l_   _o_k        _w_kill
      _j_   ^^_n_ew-copy  _r_eset
  ^^        ^^_e_xchange  _u_ndo
  ^^^^      ^^            _y_ank
    "
      ("h" backward-char nil)
      ("l" forward-char nil)
      ("k" previous-line nil)
      ("j" next-line nil)
      ("<left>" backward-char nil)
      ("<right>" forward-char nil)
      ("<up>" previous-line nil)
      ("<down>" next-line nil)
      ("e" exchange-point-and-mark nil)
      ("n" copy-rectangle-as-kill nil)
      ("d" delete-rectangle nil)
      ("r" (if (region-active-p)
               (deactivate-mark)
             (rectangle-mark-mode 1)) nil)
      ("y" yank-rectangle nil)
      ("u" undo nil)
      ("s" string-rectangle nil)
      ("w" kill-rectangle nil)
      ("o" nil nil)
      ("q" nil nil)
      )
    (global-set-key (kbd "C-x SPC") 'hydra-rectangle/body))


#+end_src
** KeyChord

I try to hit the keys at the same time so I want a really short delay.
#+begin_src emacs-lisp
(setq key-chord-two-keys-delay 0.05)
#+end_src

** Smart Mode line

#+begin_src emacs-lisp
  (use-package smart-mode-line
    :defer 2
    :ensure t
    :config
    (sml/setup))

#+end_src

** Flycheck

** ISpell
#+begin_src emacs-lisp
  (use-package ispell
    :ensure t
    :bind ("M-." . ispell-word)
    :commands (ispell-word))
#+end_src

** Auto complete ISpell
#+begin_src emacs-lisp
  (use-package ac-ispell
    :ensure t
    :commands (ac-ispell-ac-setup)
    :init (add-hook 'text-mode-hook 'ac-ispell-ac-setup)
    :config (ac-ispell-setup))
#+end_src


** Dash

Api docs for os x. Open a seperate app. Not sure if I like it yet.
#+BEGIN_SRC emacs-lisp
(use-package dash-at-point
  :ensure t
  :bind (("s-D"     . dash-at-point)
         ("C-c e"   . dash-at-point-with-docset)))
#+END_SRC


** which-key

An improved version of guide-key
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :defer 5
    :config
    (which-key-mode)
    (setq which-key-use-C-h-for-paging t
          which-key-prevent-C-h-from-cycling t
          which-key-idle-delay 0.5)
    (which-key-setup-side-window-right-bottom)
    (add-hook 'which-key-mode-hook 'jmb-disable-show-trailing-whitespace))
#+end_src


** Browse kill ring
#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
:disabled t
    :bind ("M-y" . browse-kill-ring)
    :ensure t)

#+END_SRC


* Major modes

** IBuffer


#+begin_src emacs-lisp
  ;;(require 'vc)
  (use-package ibuffer-vc
      :ensure t
      :commands (ibuffer-vc-set-filter-groups-by-vc-root))

  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer)
    :config
    (require 'ibuf-ext)
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (ibuffer-do-sort-by-alphabetic))))

#+end_src

** Elfeed (Rss)
#+begin_src emacs-lisp
  (defvar jmb-elfeed-auto-update-timer)
  (defvar jmb-elfeed-auto-update-min-delay (* 60 60))
  (defvar jmb-elfeed-auto-update-idle-delay (* 10 60))
  (defun jmb-elfeed-update ()
    (let ((idle-time (current-idle-time)))
      (when (and idle-time
                 (> (float-time idle-time) jmb-elfeed-auto-update-idle-delay)
                 (> (- (float-time) (elfeed-db-last-update)) jmb-elfeed-auto-update-min-delay))
        (message "Starting elfeed update")
        (elfeed-update))))
  (defun jmb-elfeed-start-auto-update ()
    (interactive)
    (setq jmb-elfeed-auto-update-timer (run-at-time 0 600 #'jmb-elfeed-update))
    (add-hook 'kill-buffer-hook 'jmb-elfeed-stop-auto-update nil t))
  (defun jmb-elfeed-stop-auto-update ()
    (interactive)
    (when (timerp jmb-elfeed-auto-update-timer)
      (cancel-timer jmb-elfeed-auto-update-timer)
      (setq jmb-elfeed-auto-update-timer nil)))
  (use-package elfeed
    :commands (elfeed)
    :disabled t
    :ensure t
    :config
    (progn
      (add-hook 'elfeed-search-mode-hook 'jmb-disable-show-trailing-whitespace)
      (add-hook 'elfeed-show-mode-hook 'jmb-disable-show-trailing-whitespace)
      ;;    (add-hood 'elfeed-search-mode-hook 'jmb-elfeed-start-auto-update)
      (elfeed-org)))
  (use-package elfeed-org
    :disabled t
    :commands (elfeed-org)
    :ensure t)

#+end_src


* Edit Server
#+begin_src emacs-lisp
  (use-package edit-server
    :ensure t
    :defer 5
    :config (edit-server-start))
#+end_src

